# Message we display for inspection if user uses custom class type members that do not exist
custom.type.mimic.name=Dynamic class based on {0}

### Refactoring

refactoring.extract.method.error.interrupted.execution.flow=Cannot perform refactoring when execution flow is interrupted
refactoring.extract.method.error.star.import=Cannot perform refactoring with star import statement inside code block
refactoring.extract.method.error.yield=Cannot perform refactoring with 'yield' statement inside code block

### Annotators ###
ANN.deleting.none=Deleting None
ANN.assign.to.none=Assignment to None
ANN.cant.assign.to.call=Can't assign to function call
ANN.cant.delete.call=Can't delete function call
ANN.cant.aug.assign.to.generator=Augmented assign to generator expression not possible
ANN.cant.aug.assign.to.tuple.or.generator=Augmented assign to tuple literal or generator expression not possible
ANN.cant.assign.to.generator=Assign to generator expression not possible
ANN.cant.assign.to.operator=Can't assign to operator
ANN.cant.assign.to.parens=Can't assign to ()
ANN.cant.aug.assign.to.list.or.comprh=Augmented assign to list literal or comprehension not possible
ANN.cant.assign.to.comprh=Can't assign to list comprehension
ANN.cant.assign.to.dict.comprh=Can't assign to dict comprehension
ANN.cant.assign.to.set.comprh=Can't assign to set comprehension
ANN.cant.aug.assign.to.comprh=Augmented assign to list comprehension not possible
ANN.cant.aug.assign.to.dict.comprh=Augmented assign to dict comprehension not possible
ANN.cant.aug.assign.to.set.comprh=Augmented assign to set comprehension not possible
ANN.cant.assign.to.literal=Can't assign to literal
ANN.cant.delete.literal=Can't delete literal
ANN.cant.assign.to.lambda=Can't assign to lambda

ANN.break.outside.loop='break' outside loop
ANN.continue.outside.loop='continue' outside loop

ANN.$0.assigned.before.global.decl=Name ''{0}'' is assigned before global declaration

ANN.duplicate.param.name=duplicate parameter name
ANN.starred.param.after.kwparam=* parameter after ** parameter
ANN.regular.param.after.vararg=regular parameter after * parameter
ANN.regular.param.after.keyword=regular parameter after ** parameter
ANN.non.default.param.after.default=non-default parameter follows default parameter
ANN.named.parameters.after.star=named parameters must follow bare *
ANN.named.parameters.before.slash=named parameters must precede bare /
ANN.tuple.py3=tuple parameter unpacking is not supported in Python 3
ANN.multiple.args=multiple * parameters are not allowed
ANN.multiple.kwargs=multiple ** parameters are not allowed
ANN.multiple.slash=multiple / parameters are not allowed
ANN.slash.param.after.vararg=/ parameter must precede * parameter
ANN.slash.param.after.keyword=/ parameter must precede ** parameter

ANN.star.import.at.top.only='import *' only allowed at module level

ANN.missing.closing.quote=Missing closing quote [{0}]
ANN.missing.closing.triple.quotes=Missing closing triple quotes

ANN.method.$0.removed.use.$1=Method ''{0}'' has been removed, use ''{1}'' instead
ANN.method.$0.removed=Method ''{0}'' removed

### parsing
PARSE.expected.expression=expression expected
PARSE.expected.rbracket=']' expected
PARSE.expected.expr.or.comma.or.bracket=expected expression, ',' or ']'
PARSE.expected.in='in' expected
PARSE.expected.for.or.bracket=']' or 'for' expected
PARSE.expected.comma=',' expected
PARSE.expected.colon=':' expected
PARSE.expected.rpar=')' expected
PARSE.expected.lpar='(' expected
PARSE.expected.rbrace='}' expected
PARSE.expected.tick='`' (backtick) expected
PARSE.expected.name=name expected
PARSE.expected.colon.or.rbracket=':' or ']' expected
PARSE.expected.comma.or.rpar=',' or ')' expected
PARSE.expected.else='else' expected

PARSE.expected.identifier=Identifier expected
PARSE.expected.comma.lpar.rpar=',' or '(' or ')' expected
PARSE.expected.statement.break=Statement break expected
PARSE.expected.@.or.def='@' or 'def' expected
PARSE.expected.formal.param.name=formal parameter name expected
PARSE.0.expected={0} expected
PARSE.expected.ellipsis='...' expected

statement.expected.found.0=Statement expected, found {0}
unexpected.indent=Unexpected indent
unindent.does.not.match.any.outer.indent=Unindent does not match any outer indentation level
except.or.finally.expected='except' or 'finally' expected
expected.statement=Statement expected
dedent.expected=Dedent expected
indent.expected=Indent expected
indented.block.expected=Indented block expected
cannot.assign.to.yield.expression=Cannot assign to 'yield' expression
end.of.statement.expected=End of statement expected
import.expected='import' expected
def.or.with.or.for.expected='def' or 'with' or 'for' expected
rbracket.or.comma.expected=']' or ',' expected
unexpected.expression.syntax=Unexpected expression syntax
tuple.expression.expected=tuple expression expected
value.expression.expected=value expression expected
unexpected.expression.part=unexpected expression part
unexpected.f.string.token=unexpected f-string token
can.t.assign.to.await.expression=can't assign to await expression
for.expected='for' expected
rarrow.expected='->' expected
unexpected.tokens=unexpected tokens

PARSE.function.type.annotations.py2=Type annotations are unsupported in Python 2
PARSE.function.return.type.annotations.py2=Return type annotations are unsupported in Python 2

PARSE.console.multiline.magic.warn=Multiline magic can't be used as an expression
PARSE.console.identifier.expected=Identifier expected.
PARSE.console.help.request.warn=Help request must follow the name

### quick doc generator
QDOC.module.path.unknown=(Module path is unknown)
QDOC.epydoc.python2.sdk.not.found=You need configured Python 2 SDK to render <a href='http://epydoc.sourceforge.net/'>Epydoc</a> docstrings
QDOC.local.sdk.not.found=You need a configured local Python SDK to render docstrings.
QDOC.assigned.to=Assigned to:
QDOC.documentation.is.copied.from=Documentation is copied from:
QDOC.accessor.kind=Accessor kind:
QDOC.raises=Raises:
QDOC.keyword.args=Keyword args:
QDOC.returns=Returns:
QDOC.params=Params:

### Formatter
formatter.panel.dict.alignment.do.not.align=Do not align
formatter.panel.dict.alignment.align.on.colon=Align on colon
formatter.panel.dict.alignment.align.on.value=Align on value

QFIX.add.field.to.class=Add field to class
QFIX.added.constructor.$0.for.field.$1=Added a __init__ to class <code>{0}</code><br/>to accommodate new field <code>{1}</code>
QFIX.NAME.remove.parameter=Remove parameter
QFIX.rename.parameter.to.$0=Rename to ''{0}''
QFIX.NAME.add.field.$0.to.class.$1=Add field ''{0}'' to class {1}
QFIX.NAME.remove.statement=Remove statement
QFIX.failed.to.add.field=<br/>Failed to add a field!<br/><br/>

#PyDefaultArgumentQuickFix
QFIX.default.argument=Replace mutable default argument

QFIX.redundant.parentheses=Remove redundant parentheses

QFIX.simplify.boolean.expression=Simplify boolean expression
QFIX.simplify.$0=Replace boolean expression with ''{0}''

QFIX.chained.comparison=Simplify chained comparison

INSP.GROUP.python=Python

# PyUnresolvedReferencesInspection
INSP.NAME.unresolved.refs=Unresolved references
INSP.module.$0.not.found=Module ''{0}'' not found
INSP.unresolved.ref.$0=Unresolved reference ''{0}''
INSP.unresolved.ref.$0.for.class.$1=Unresolved attribute reference ''{0}'' for class ''{1}''
INSP.cannot.find.$0.in.$1=Cannot find reference ''{0}'' in ''{1}''
INSP.unresolved.operator.ref=Class ''{0}'' does not define ''{1}'', so the ''{2}'' operator cannot be used on its instances
python.stub=Python stub

# PyRedundantParenthesesInspection
INSP.NAME.redundant.parentheses=Redundant parentheses
INSP.redundant.parens.ignore.empty.lists.of.base.classes=Ignore empty lists of base classes
INSP.redundant.parens.ignore.tuples=Ignore tuples
INSP.redundant.parens.ignore.argument.of.operator=Ignore argument of % operator

# PySimplifyBooleanCheckInspection
INSP.NAME.check.can.be.simplified=Boolean variable check can be simplified
INSP.expression.can.be.simplified=Expression can be simplified
INSP.simplify.boolean.check.ignore.comparison.to.zero=Ignore comparison to zero

# Actions and associated commands
ACT.CMD.use.import=Use an imported module
ACT.qualify.with.module=Qualify with an imported module
ACT.from.some.module.import=Import from ...

### Quick fixes ###
QFIX.auto.import.family=Import
QFIX.auto.import.import.this.name=Import this name
QFIX.auto.import.import.name=Import ''{0}''

QFIX.local.auto.import.family=Import locally
QFIX.local.auto.import.import.locally={0} locally

python.docstring.file.type=python docstring
python.function.type.annotation.file.type.description=Python PEP-484 function type comment
# PyUnusedLocalInspection
INSP.NAME.unused=Unused local
INSP.unused.locals.parameter.isnot.used=Parameter ''{0}'' value is not used
INSP.unused.locals.local.variable.isnot.used=Local variable ''{0}'' value is not used
INSP.unused.locals.replace.with.wildcard=Replace with _
INSP.unused.locals.local.function.isnot.used=Local function ''{0}'' is not used
INSP.unused.locals.local.class.isnot.used=Local class ''{0}'' is not used

INSP.unused.locals.ignore.variables.starting.with=Ignore variables starting with '_'
INSP.unused.locals.ignore.range.iteration.variables=Ignore range iteration variables
INSP.unused.locals.ignore.lambda.parameters=Ignore lambda parameters
INSP.unused.locals.ignore.variables.used.in.tuple.unpacking=Ignore variables used in tuple unpacking

find.usages.unnamed=<unnamed>
find.usages.keyword.argument=keyword argument
find.usages.variable=variable
find.usages.imported.module.alias=imported module alias
find.usages.class=class
find.usages.function=function
find.usages.method=method
find.usages.parameter=parameter

python.find.usages=Find Usages
python.find.usages.base.method.question=Method {0} overrides method of class {1}.\nDo you want to find usages of the base method?
python.find.usages.usage.in.superclass.list=Usage in superclass list
python.find.usages.usage.in.isinstance=Usage in isinstance()
python.find.usages.untyped.probable.usage=Untyped (probable) usage
python.find.usages.usage.in.import.statement=Usage in import statement
